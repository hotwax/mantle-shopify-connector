<?xml version="1.0" encoding="UTF-8"?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://moqui.org/xsd/service-definition-3.xsd">
    <service verb="consume" noun="FulfillmentFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Consume Fulfillment Feed JSON System Message and produce 'CreateShopifyFulfillment' System Message for each record.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="shipments" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <!-- NOTE: With change in poll#SystemMessageFileSftp service, the messageText will hold the file path
                instead of the file content, so removed null check on fileText, instead we need to check the
                expected shipments data being read from the filePath.
                If no shipments, one scenario is transformation in NiFi generating file with null value as no
                valid shipments data, or it may be due to some other unexpected JSON generated to be consumed,
                then the file can be checked further for any possible issue. -->
            <if condition="!shipments">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with Fulfillment Feed file having incorrect data and may contain null, not consuming the feed file."/>
            </if>
            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="consumeSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="consumeSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="!consumeSmrParam || !consumeSmrParam.parameterValue">
                <return error="true" message="consumeSmrId not set for SystemMessageType [${systemMessage.systemMessageTypeId}]"/>
            </if>
            <iterate list="shipments" entry="shipment">
                <set field="messageText" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.writeValueAsString(shipment)"/>
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" in-map="[systemMessageTypeId:'CreateShopifyFulfillment', systemMessageRemoteId:consumeSmrParam.parameterValue, messageText:messageText, sendNow:true, orderId: shipment.orderId, mode: 'sync']"
                              out-map="context" ignore-error="true" transaction="force-new"/>
            </iterate>
        </actions>
    </service>
    <service verb="send" noun="ShopifyFulfillmentSystemMessage" authenticate="anonymous-all">
        <description>
            Send service to invoke Create Shopify Fulfillment API for the System Message.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <set field="shipment" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>
            <set field="lineItems" from="[]"/>
            <iterate list="shipment.shipmentItems" entry="shipmentItem">
                <set field="lineItem" from="[:]"/>
                <set field="lineItem.shopifyLineItemId" from="shipmentItem.shopifyOrderLineId"/>
                <set field="lineItem.quantity" from="shipmentItem.quantity"/>
                <script>lineItems.add(lineItem)</script>
            </iterate>

            <set field="fulfillmentContext" from="[:]"/>
            <set field="fulfillmentContext.lineItems" from="lineItems"/>
            <set field="fulfillmentContext.shopifyOrderId" from="shipment.shopifyOrderId"/>
            <set field="fulfillmentContext.trackingNumber" from="shipment.trackingNumber"/>
            <set field="fulfillmentContext.trackingUrl" from="shipment.trackingUrl"/>
            <set field="fulfillmentContext.carrier" from="shipment.carrierPartyId"/>
            <set field="fulfillmentContext.notifyCustomer" from="shipment.notifyCustomer"/>
            <set field="fulfillmentContext.systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            <service-call name="co.hotwax.shopify.fulfillment.ShopifyFulfillmentServices.create#Fulfillment" in-map="fulfillmentContext" out-map="outMap"/>

            <set field="remoteMessageId" from="outMap.shopifyFulfillmentId"/>
        </actions>
    </service>

    <service verb="send" noun="ShopifyFulfillmentSystemMessageV2" authenticate="anonymous-all">
        <description>
            Send service to invoke Create Shopify Fulfillment API for the System Message.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <set field="shipment" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>
            <set field="shipment.systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>

            <service-call name="co.hotwax.shopify.fulfillment.ShopifyFulfillmentServices.create#Fulfillment" in-map="shipment" out-map="outMap"/>

            <set field="remoteMessageId" from="outMap.shopifyFulfillmentId"/>
        </actions>
    </service>

    <service verb="consume" noun="GraphQLBulkImportFeed" authenticate="anonymous-all">
        <description>
            Consume Bulk Import Feed System Message, upload bulk import feed to Shopify's staged upload url
            and produce corresponding shopify bulk mutation system message.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <if condition="!systemMessage.messageText">
                <return type="warning" message="System message [${systemMessageId}] for Type ${systemMessage?.systemMessageTypeId} has no message text, not consuming."/>
            </if>

            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="!enumValue || !enumValue.relatedEnumId">
                <return type="warning" message="Related SystemMessageType to produce for ${systemMessage?.systemMessageTypeId} not defined, not consuming."/>
            </if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="consumeSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="consumeSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="!consumeSmrParam || !consumeSmrParam.parameterValue">
                <return type="warning" message="consumeSmrId not set for SystemMessageType [${systemMessage.systemMessageTypeId}], not consuming"/>
            </if>

            <service-call name="co.hotwax.shopify.graphQL.ShopifyBulkImportServices.get#JsonlStagedUploadUrl" in-map="[systemMessageRemoteId:consumeSmrParam.parameterValue, fileName:systemMessage.remoteMessageId]"
                          out-map="context"/>

            <service-call name="co.hotwax.shopify.graphQL.ShopifyBulkImportServices.upload#JsonlFileToShopify" in-map="[stagedUploadUrlMap:stagedUploadUrlMap, fileLocation:systemMessage.messageText, fileName:systemMessage.remoteMessageId]"
                          out-map="context"/>

            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" in-map="[systemMessageTypeId:enumValue.relatedEnumId, systemMessageRemoteId:consumeSmrParam.parameterValue, messageText:stagedUploadPath, sendNow:false]"
                          out-map="context"/>
        </actions>
    </service>
    <service verb="send" noun="BulkMutationSystemMessage" authenticate="anonymous-all">
        <description>
            Send service to invoke Run Shopify Bulk Operation Mutation API for the System Message.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <set field="requestBody" from="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, mutationTemplateLocation:systemMessage.sendPath,
                                  stagedUploadPath: systemMessage.messageText]"/>

            <entity-find entity-name="moqui.service.message.SystemMessageTypeParameter" list="additionalParameters">
                <econdition field-name="systemMessageTypeId" operator="equals" from="systemMessage.systemMessageTypeId"/>
                <econdition field-name="systemMessageRemoteId" operator="equals" from="systemMessage.systemMessageRemoteId"/>
            </entity-find>
            <if condition="additionalParameters">
                <iterate list="additionalParametrs" entry="paramMap">
                    <script>requestBody.put(${paramMap.parameterName}, ${paramMap.parameterValue})</script>
                </iterate>
            </if>

            <service-call name="co.hotwax.shopify.graphQL.ShopifyBulkImportServices.run#BulkOperationMutation"
                          in-map="requestBody" out-map="context"/>

            <set field="remoteMessageId" from="shopifyBulkOperationId"/>
        </actions>
    </service>
    <service verb="send" noun="ProducedBulkOperationSystemMessage" authenticate="anonymous-all">
        <description>
            Scheduled service to send next bulk operation in the queue.
        </description>
        <in-parameters>
            <parameter name="parentSystemMessageTypeId" required="true"/>
            <parameter name="retryLimit" type="Integer" default="3"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="moqui.service.message.SystemMessageAndType" list="sentSystemMessages">
                <econdition field-name="statusId" operator="equals" value="SmsgSent"/>
                <econdition field-name="parentTypeId" operator="equals" from="parentSystemMessageTypeId"/>
            </entity-find>
            <if condition="sentSystemMessages">
                <return message="Aborting, ${parentSystemMessageTypeId} Operation already in progress."/>
            </if>
            <entity-find entity-name="moqui.service.message.SystemMessageAndType" list="producedSystemMessages" limit="1">
                <econdition field-name="statusId" operator="equals" value="SmsgProduced"/>
                <econdition field-name="parentTypeId" operator="equals" from="parentSystemMessageTypeId"/>
                <order-by field-name="initDate"/>
            </entity-find>
            <if condition="!producedSystemMessages">
                <return message="Aborting, no ${parentSystemMessageTypeId} Operation System Messages found to process."/>
            </if>

            <if condition="producedSystemMessages[0].failCount &lt; retryLimit">
                <service-call name="org.moqui.impl.SystemMessageServices.send#ProducedSystemMessage"
                              in-map="[systemMessageId:producedSystemMessages[0].systemMessageId]"/>
                <else>
                    <service-call name="update#moqui.service.message.SystemMessage"
                                  in-map="[systemMessageId:producedSystemMessages[0].systemMessageId, statusId:'SmsgError',
                                    lastAttemptDate:ec.user.nowTimestamp]"/>
                </else>
            </if>
        </actions>
    </service>
    <service verb="process" noun="BulkOperationResult" authenticate="anonymous-all">
        <description>
            Fetch and process the bulk operations result for a sent system message and create respective incoming
            system message for further processing the result file link.
        </description>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <set field="statusMap" from="[completed:'SmsgConfirmed', canceled:'SmsgCancelled', failed:'SmsgError', expired:'SmsgError']"/>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <service-call name="co.hotwax.shopify.graphQL.ShopifyBulkImportServices.get#BulkOperationResult" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyBulkOperationId:systemMessage.remoteMessageId]"
                          out-map="bulkOperationResult"/>

            <set field="status" from="bulkOperationResult.response.status"/>
            <if condition="!status">
                <set field="status" value="failed"/>
            </if>
            <if condition="'created'.equalsIgnoreCase(status) || 'running'.equalsIgnoreCase(status)">
                <set field="responseText" value="The bulk operation for systemMessageId:[${systemMessageId}] with systemMessageType:[${systemMessage.systemMessageTypeId}] not yet completed at Shopify."/>
            </if>
            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <if condition="'failed'.equalsIgnoreCase(status)">
                <service-call name="create#moqui.service.message.SystemMessageError" in-map="[systemMessageId:systemMessageId, errorDate:nowDate, errorText:bulkOperationResult.response.errorCode]"/>
                <set field="responseText" value="The bulk operation for systemMessageId:[${systemMessageId}] with systemMessageType:[${systemMessage.systemMessageTypeId}] failed at Shopify with errorCode:[${bulkOperationResult.response.errorCode}]."/>
            </if>
            <if condition="'expired'.equalsIgnoreCase(status)">
                <service-call name="create#moqui.service.message.SystemMessageError" in-map="[systemMessageId:systemMessageId, errorDate:nowDate, errorText:'The bulk operation URL has expired.']"/>
                <set field="responseText" value="The bulk operation for systemMessageId:[${systemMessageId}] with systemMessageType:[${systemMessage.systemMessageTypeId}] expired at Shopify with errorCode:[${bulkOperationResult.response.errorCode}]."/>
            </if>
            <if condition="'completed'.equalsIgnoreCase(status) &amp;&amp; !bulkOperationResult.response.url">
                <set field="responseText" value="The bulk operation for systemMessageId:[${systemMessageId}] with systemMessageType:[${systemMessage.systemMessageTypeId}] completed successfully at Shopify but no result url received."/>
            </if>
            <service-call name="update#moqui.service.message.SystemMessage" in-map="[systemMessageId:systemMessageId, statusId:statusMap.get(status.toLowerCase())]"/>

            <if condition="responseText">
                <return message="${responseText}"/>
            </if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="consumeSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="consumeSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="consumeSmrParam">
                <set field="consumeSmrId" from="consumeSmrParam.parameterValue"/>
            </if>

            <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:systemMessage.systemMessageTypeId, messageText:bulkOperationResult.response.url,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, remoteMessageId:systemMessageId, consumeSmrId:consumeSmrId]"/>
        </actions>
    </service>
    <service verb="consume" noun="BulkOperationResult" authenticate="anonymous-all">
        <description>
            Consume service to download and store result file for received bulk operation result system message.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <entity-find-related-one value-field="systemMessage" relationship-name="type" to-value-field="systemMessageType"/>

            <set field="nowDate" from="ec.l10n.format(ec.user.nowTimestamp, 'yyyy-MM-dd-HH-mm-ss', null, TimeZone.getDefault())"/>
            <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager'"/>
            <set field="urlMap" from="[nowDate:nowDate, contentRoot:contentRoot, systemMessageId:systemMessage.systemMessageId, remoteMessageId:systemMessage.remoteMessageId]"/>
            <set field="fileLocation" from="ec.resourceFacade.expand(systemMessageType.receivePath, null, urlMap)"/>

            <service-call name="co.hotwax.shopify.graphQL.ShopifyBulkImportServices.store#BulkOperationResultFile"
                          in-map="[downloadUrl:systemMessage.messageText, fileLocation:fileLocation]" out-map="context"/>

            <if condition="systemMessage.consumeSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="!enumValue || !enumValue.relatedEnumId">
                    <return type="warning" message="Related SystemMessageType to produce for ${systemMessage?.systemMessageTypeId} not defined, not sending result file to sftp."/>
                </if>

                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" in-map="[systemMessageTypeId:enumValue.relatedEnumId, systemMessageRemoteId:systemMessage.consumeSmrId, messageText:fileLocation,
                          remoteMessageId:fileLocation.substring(fileLocation.lastIndexOf('/')+1), sendNow:true]" out-map="context"/>
            </if>
        </actions>
    </service>
    <service verb="poll" noun="BulkOperationResult" authenticate="anonymous-all">
        <description>
            Polling service to fetch and process bulk operation result for a sent bulk mutation or query system message.
        </description>
        <in-parameters>
            <parameter name="parentSystemMessageTypeId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="moqui.service.message.SystemMessageAndType" list="systemMessages" limit="1">
                <econdition field-name="statusId" operator="equals" value="SmsgSent"/>
                <econdition field-name="parentTypeId" operator="equals" from="parentSystemMessageTypeId"/>
            </entity-find>
            <if condition="!systemMessages">
                <return message="No bulk operation in progress."/>
            </if>
            <service-call name="co.hotwax.shopify.system.ShopifySystemMessageServices.process#BulkOperationResult"
                          in-map="[systemMessageId:systemMessages[0].systemMessageId]" out-map="context"/>
        </actions>
    </service>
    <service verb="queue" noun="BulkQuerySystemMessage" authenticate="anonymous-all">
        <description>
            Scheduled service to queue a bulk query system message of a specific SystemMessageType.
        </description>
        <in-parameters>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="filterQuery"/>
            <parameter name="fromDate"/>
            <parameter name="thruDate"/>
            <parameter name="fromDateLabel"/>
            <parameter name="thruDateLabel"/>
        </in-parameters>
        <actions>
            <set field="queryParams" from="[:]"/>
            <entity-find entity-name="moqui.service.message.SystemMessageTypeParameter" list="additionalParameters">
                <econdition field-name="systemMessageTypeId" operator="equals" from="systemMessageTypeId"/>
                <econdition field-name="systemMessageRemoteId" operator="equals" from="systemMessageRemoteId"/>
            </entity-find>
            <if condition="additionalParameters">
                <iterate list="additionalParameters" entry="paramMap">
                    <script>queryParams.put(paramMap.parameterName, paramMap.parameterValue)</script>
                </iterate>
            </if>
            <if condition="filterQuery">
                <set field="queryParams.filterQuery" from="filterQuery"/>
            </if>
            <if condition="queryParams.filterQuery">
                <set field="queryParams.filterQuery" from="org.apache.commons.text.StringEscapeUtils.unescapeHtml4(queryParams.filterQuery)"/>
            </if>
            <if condition="!fromDate">
                <entity-find entity-name="moqui.service.message.SystemMessage" list="systemMessageList" limit="1">
                    <econdition field-name="systemMessageTypeId" operator="equals" from="systemMessageTypeId"/>
                    <econdition field-name="statusId" operator="equals" value="SmsgConfirmed"/>
                    <order-by field-name="-processedDate"/>
                </entity-find>
                <if condition="systemMessageList">
                    <set field="fromDate" from="systemMessageList[0].processedDate" type="String"/>
                </if>
            </if>
            <if condition="fromDate">
                <set field="fromZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(fromDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <if condition="queryParams.fromDateBuffer">
                    <set field="fromZdtUTC" from="fromZdtUTC.minusMinutes(Integer.valueOf(queryParams.fromDateBuffer))"/>
                </if>
                <set field="queryParams.fromDate" from="fromZdtUTC.toString()"/>
            </if>
            <if condition="thruDate">
                <set field="thruZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(thruDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <if condition="queryParams.thruDateBuffer">
                    <set field="thruZdtUTC" from="thruZdtUTC.minusMinutes(Integer.valueOf(queryParams.thruDateBuffer))"/>
                </if>
                <set field="queryParams.thruDate" from="thruZdtUTC.toString()"/>
            </if>
            <if condition="fromDateLabel">
                <set field="queryParams.fromDateLabel" from="fromDateLabel"/>
            </if>
            <if condition="thruDateLabel">
                <set field="queryParams.thruDateLabel" from="thruDateLabel"/>
            </if>
            <set field="messageText" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.writeValueAsString(queryParams)"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                          in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId, messageText:messageText, sendNow:false]"
                          out-map="context"/>
        </actions>
    </service>
    <service verb="send" noun="BulkQuerySystemMessage" authenticate="anonymous-all">
        <description>
            Send service to invoke Run Shopify Bulk Operation Query API for the System Message.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <set field="bulkQueryContext" from="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryTemplateLocation:systemMessage.sendPath]"/>
            <set field="bulkQueryContext.queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <service-call name="co.hotwax.shopify.graphQL.ShopifyBulkImportServices.run#BulkOperationQuery"
                          in-map="bulkQueryContext" out-map="context"/>

            <set field="remoteMessageId" from="shopifyBulkOperationId"/>
        </actions>
    </service>
    <service verb="consume" noun="BulkOperationsFinishWebhookPayload" authenticate="anonymous-all">
        <description>Consume service to process bulk_operations/finish wehbook payload</description>
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <set field="payload" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <entity-find entity-name="moqui.service.message.SystemMessage" list="bulkOperationList">
                <econdition field-name="remoteMessageId" from="payload.admin_graphql_api_id"/>
                <econdition field-name="isOutgoing" operator="equals" value="Y"/>
            </entity-find>
            <if condition="!bulkOperationList">
                <return error="true" message="No outgoing SystemMessage record found for bulk operation [${payload.admin_graphql_api_id}]"/>
            </if>
            <if condition="!'SmsgSent'.equals(bulkOperationList[0].statusId)">
                <return error="true" message="Payload already consumed for bulk operation [${payload.admin_graphql_api_id}]"/>
            </if>

            <service-call name="co.hotwax.shopify.system.ShopifySystemMessageServices.process#BulkOperationResult"
                          in-map="[systemMessageId:bulkOperationList[0].systemMessageId]" out-map="context"/>
        </actions>
    </service>
    <service verb="consume" noun="SyncedRefundsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>
            Consume Synced Refunds Feed JSON System Message, get return reasons from shopify for each refund and send return reason feed to SFTP.
        </description>
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="refunds" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!refunds">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with Synced Refunds Feed file having incorrect data and may contain null, not consuming the feed file."/>
            </if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="consumeSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="consumeSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="!consumeSmrParam || !consumeSmrParam.parameterValue">
                <return error="true" message="consumeSmrId not set for SystemMessageType [${systemMessage.systemMessageTypeId}]"/>
            </if>

            <!-- Prepare Shopify Return Reason Feed File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
            [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
            dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="!enumValue || !enumValue.relatedEnumId">
                <log level="warn" message="Related SystemMessageType to produce for ${systemMessage?.systemMessageTypeId} not defined,  not producing related system message."/>
            </if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
            </entity-find-one>
            <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                //json file
                File feedFile = new File(jsonFilePath)
                if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                JsonFactory jfactory = new JsonFactory()

                /* Declaring the PrintWriter and JsonGenerator resources in the the try statement,
                so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                jGenerator.writeStartArray()
            </script>

            <iterate list="refunds" entry="refund">
                <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#ReturnLineItemsByRefund" in-map="[systemMessageRemoteId:consumeSmrParam.parameterValue, refundId:refund.refundId]"
                              out-map="context" ignore-error="true" transaction="force-new"/>

                <if condition="refundDetail">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, refundDetail)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Shopify Return Reason Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:systemMessage.systemMessageRemoteId,
                                   messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="sendReturnReasonFeedOut" ignore-error="true" transaction="force-new"/>
            </if>
        </actions>
    </service>
    <service verb="consume" noun="OrderIdsFeed" authenticate="anonymous-all">
        <description>Consume orderIds JSON feed and queue GenerateOrderMetafields system message.</description>
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="!enumValue || !enumValue.relatedEnumId">
                <return type="warning" message="Related SystemMessageType to produce for ${systemMessage?.systemMessageTypeId} not defined, not consuming."/>
            </if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType">
                <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
            </entity-find-one>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="consumeSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="consumeSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="!consumeSmrParam || !consumeSmrParam.parameterValue">
                <return error="true" message="consumeSmrId not set for SystemMessageType [${systemMessage.systemMessageTypeId}]"/>
            </if>

            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                          in-map="[systemMessageTypeId:systemMessageType.systemMessageTypeId, systemMessageRemoteId:consumeSmrParam.parameterValue,
                                   messageText:systemMessage.messageText, sendNow:true]"
                          out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
        </actions>
    </service>
    <service verb="generate" noun="OrderMetafieldsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate order metafields json feed for the give orderIds feed, send to SFTP if configured.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage">
                <field-map field-name="systemMessageId"/>
            </entity-find-one>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="orders" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!orders">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with OrderIds Feed file having incorrect data and may contain null, not generating order metfields feed file."/>
            </if>

            <!-- Prepare Order Metafields Feed File Path -->
            <!-- Using sendPath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="consumeSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="consumeSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="consumeSmrParam">
                <set field="consumeSmrId" from="consumeSmrParam.parameterValue"/>
            </if>

            <if condition="consumeSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="consumeSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="namespacesParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="namespaces"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="namespacesParam &amp;&amp; namespacesParam.parameterValue">
                <set field="namespaces" from="namespacesParam.parameterValue.split(',')"/>
            </if>

            <iterate list="orders" entry="order">
                <set field="metafields" from="[]"/>
                <if condition="!namespaces">
                    <service-call name="co.hotwax.shopify.order.ShopifyOrderServices.get#OrderMetafields" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.shopifyOrderId]"
                                  out-map="orderMetafieldsResponse" ignore-error="true" transaction="force-new"/>
                    <if condition="orderMetafieldsResponse.orderMetafields">
                        <set field="metafields" from="orderMetafieldsResponse.orderMetafields"/>
                    </if>
                    <else>
                        <iterate list="namespaces" entry="namespace">
                            <service-call name="co.hotwax.shopify.order.ShopifyOrderServices.get#OrderMetafields" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.shopifyOrderId, namespace:namespace]"
                                          out-map="orderMetafieldsResponse" ignore-error="true" transaction="force-new"/>
                            <if condition="orderMetafieldsResponse.orderMetafields">
                                <script>metafields.addAll(orderMetafieldsResponse.orderMetafields)</script>
                            </if>
                        </iterate>
                    </else>
                </if>
                <set field="orderMetafieldsMap" from="[:]"/>
                <set field="orderMetafieldsMap.shopifyOrderId" from="order.shopifyOrderId"/>
                <set field="orderMetafieldsMap.metafields" from="metafields"/>
                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderMetafieldsMap)
                </script>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Order Metafields Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:consumeSmrId,
                                       messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>
        </actions>
    </service>
    <service verb="queue" noun="ReturnedOrderIdsFeed" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="fromDate"/>
            <parameter name="thruDate"/>
        </in-parameters>
        <actions>
            <set field="queryParams" from="[:]"/>
            <if condition="!fromDate">
                <entity-find entity-name="moqui.service.message.SystemMessage" list="systemMessageList" limit="1">
                    <econdition field-name="systemMessageTypeId" operator="equals" from="systemMessageTypeId"/>
                    <econdition field-name="statusId" operator="equals" value="SmsgSent"/>
                    <order-by field-name="-processedDate"/>
                </entity-find>
                <if condition="systemMessageList">
                    <set field="fromDate" from="systemMessageList[0].processedDate" type="String"/>
                </if>
            </if>
            <if condition="fromDate">
                <set field="fromZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(fromDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.fromDate" from="fromZdtUTC.toString()"/>
            </if>
            <if condition="thruDate">
                <set field="thruZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(thruDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.thruDate" from="thruZdtUTC.toString()"/>
            </if>
            <log level="warn" message="SERVICE CALL STARTED FOR SYSTEM MESSAGE QUEUE [systemMessageTypeId:${systemMessageTypeId}, systemMessageRemoteId:${systemMessageRemoteId},
                                       messageText:${org.moqui.impl.context.ContextJavaUtil.jacksonMapper.writeValueAsString(queryParams)},  sendNow:true]"/>

            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                          in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                                       messageText:org.moqui.impl.context.ContextJavaUtil.jacksonMapper.writeValueAsString(queryParams),  sendNow:true]"
                          out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            <log level="warn" message="SERVICE CALL ENDED FOR SYSTEM MESSAGE QUEUE"/>
        </actions>
    </service>

    <service verb="queue" noun="AppeasementIdsFeed" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="fromDate"/>
            <parameter name="thruDate"/>
        </in-parameters>
        <actions>
            <set field="queryParams" from="[:]"/>
            <if condition="!fromDate">
                <entity-find entity-name="moqui.service.message.SystemMessage" list="SystemMessageList" limit="1">
                    <econdition field-name="systemMessageTypeId" operator="equals" from="systemMessageTypeId"/>
                    <econdition field-name="statusId" operator="equals" value="SmsgSent"/>
                    <order-by field-name="-processedDate"/>
                </entity-find>
                <if condition="systemMessageList">
                    <set field="fromDate" from="systemMessageList[0].processedDate" type="String"/>
                </if>
            </if>
            <if condition="fromDate">
                <set field="fromZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(fromDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.fromDate" from="fromZdtUTC.toString()"/>
            </if>
            <if condition="thruDate">
                <set field="thruZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(thruDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.thruDate" from="thruZdtUTC.toString()"/>
            </if>

            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                          in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId, sendNow:true, messageText:org.moqui.impl.context.ContextJavaUtil.jacksonMapper.writeValueAsString(queryParams)]"
                          out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
        </actions>
    </service>

    <service verb="generate" noun="ReturnedOrderIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate returned orderIds feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                    <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                </entity-find-one>

                <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                <else>
                    <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="returnedOrderIdsResponse"/>
                <if condition="!returnedOrderIdsResponse.response.orders.edges">
                    <return message="No returned orderIds found between ${queryParams.fromDate} and ${queryParams.thruDate}"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
                </script>
                <set field="returnedOrderIds" from="returnedOrderIdsResponse.response.orders.edges"/>
                <iterate list="returnedOrderIds" entry="returnedOrderIdMap">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, returnedOrderIdMap.node)
                    </script>
                </iterate>
                <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.error("Error preparing Order Metafields Feed file", e)
                    }
                </script>
                <if condition="relatedSystemMessageType">
                    <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                </if>
                <set field="hasNextPage" from="returnedOrderIdsResponse.response.orders.pageInfo.hasNextPage"/>
                <set field="cursor" from="returnedOrderIdsResponse.response.orders.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>

    <service verb="generate" noun="RefundIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate refund Ids feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                    <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                </entity-find-one>
                <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                <else>
                    <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>
            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>

            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="refundOrdersResponse"/>
                <if condition="!refundOrdersResponse.response.orders.edges">
                    <return message="No Order with refunds found between ${queryParams.fromDate} and ${queryParams.thruDate}"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null, [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try{
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)){
                        jGenerator.writeStartArray()
                </script>
                <set field="refundOrders" from="refundOrdersResponse.response.orders.edges"/>
                <iterate list="refundOrders" entry="refundOrder">
                    <iterate list="refundOrder.node.refunds" entry="refund">
                        <script>
                            new ObjectMapper()
                            .setDateFormat(new java.text.SimpleDateFormat(System.getProperty("default_date_time_format")))
                            .writerWithDefaultPrettyPrinter().writeValue(jGenerator, refund)
                        </script>
                    </iterate>
                </iterate>
                <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.error("Error preparing Order Metafields Feed file", e)
                    }
                </script>
                <if condition="relatedSystemMessageType">
                    <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                </if>
                <set field="hasNextPage" from="refundOrdersResponse.response.orders.pageInfo.hasNextPage"/>
                <set field="cursor" from="refundOrdersResponse.response.orders.pageInfo.endCursor"/>
            </while>

        </actions>
    </service>

    <service verb="generate" noun="RefundsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="sendSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="sendSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="sendSmrParam">
                <set field="sendSmrId" from="sendSmrParam.parameterValue"/>
            </if>

            <if condition="sendSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="sendSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="refundIds" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!refundIds">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with refundIds file having incorrect data and may contain null, not generating refunds feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <log message="jsonFilePath: ${jsonFilePath}"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                //json file
                ec.logger.info("jsonFilePath:" +jsonFilePath)
                File feedFile = new File(jsonFilePath)
                if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                JsonFactory jfactory = new JsonFactory()

                /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                jGenerator.writeStartArray()
            </script>
            
            <iterate list="refundIds" entry="refundId">
                <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundDetails" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, refundId:refundId.id]"
                              out-map="refundDetailsResponse" ignore-error="true" transaction="force-new"/>
                <if condition="refundDetailsResponse">
                    <set field="refundMap" from="refundDetailsResponse.refundDetail"/>
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, refundMap)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Refunds Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:sendSmrId,
                                       messageText:jsonFilePathRef, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>

        </actions>
    </service>

    <service verb="generate" noun="ReturnsAndExchangeFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="sendSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="sendSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="sendSmrParam">
                <set field="sendSmrId" from="sendSmrParam.parameterValue"/>
            </if>

            <if condition="sendSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="sendSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="orders" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!orders">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <log message="jsonFilePath: ${jsonFilePath}"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    ec.logger.info("jsonFilePath:" +jsonFilePath)
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="orders" entry="order">
                <service-call name="co.hotwax.shopify.order.ShopifyOrderServices.get#OrderDetails" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id, includeLineItems:false]"
                              out-map="orderDetailsResponse" ignore-error="true" transaction="force-new"/>

                <if condition="orderDetailsResponse.orderDetail">
                    <set field="orderMap" from="orderDetailsResponse.orderDetail"/>

                    <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#ReturnsByOrderId" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id]"
                                  out-map="orderReturnsResponse" ignore-error="true" transaction="force-new"/>
                    <set field="orderMap.returns" from="orderReturnsResponse.orderReturns.returns"/>

                    <service-call name="co.hotwax.shopify.fulfillment.ShopifyFulfillmentServices.get#FulfillmentOrdersByOrderId" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id, includeFulfillmentLineItems:false]"
                                  out-map="fulfillmentOrdersResponse" ignore-error="true" transaction="force-new"/>
                    <set field="orderMap.fulfillmentOrders" from="fulfillmentOrdersResponse.fulfillmentOrdersByOrderId.fulfillmentOrders"/>

                    <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#ExchangesByOrderId" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id]"
                                  out-map="orderExchangesResponse" ignore-error="true" transaction="force-new"/>
                    <set field="orderMap.exchanges" from="orderExchangesResponse.orderExchanges.exchanges"/>

                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderMap)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Return and Exchange Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:sendSmrId,
                                       messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>
        </actions>
    </service>
    <service verb="queue" noun="OrderIdsByTagFeed" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="tag" required="true"/>
            <parameter name="tagNot"/>
            <parameter name="fromDate"/>
            <parameter name="thruDate"/>
        </in-parameters>
        <actions>
            <set field="queryParams" from="[:]"/>
            <set field="queryParams.tag" from="tag"/>
            <set field="queryParams.tagNot" from="tagNot"/>
            <log message="tagNot: ${tagNot}"/>
            <if condition="!fromDate">
                <entity-find entity-name="moqui.service.message.SystemMessage" list="systemMessageList" limit="1">
                    <econdition field-name="systemMessageTypeId" operator="equals" from="systemMessageTypeId"/>
                    <econdition field-name="statusId" operator="equals" value="SmsgSent"/>
                    <order-by field-name="-processedDate"/>
                </entity-find>
                <if condition="systemMessageList">
                    <set field="fromDate" from="systemMessageList[0].processedDate" type="String"/>
                </if>
            </if>
            <if condition="fromDate">
                <set field="fromZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(fromDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.fromDate" from="fromZdtUTC.toString()"/>
            </if>
            <if condition="thruDate">
                <set field="thruZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(thruDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.thruDate" from="thruZdtUTC.toString()"/>
            </if>
            <log message="queryParams: ${queryParams}"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                          in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                                       messageText:org.moqui.impl.context.ContextJavaUtil.jacksonMapper.writeValueAsString(queryParams),  sendNow:true]"
                          out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
        </actions>
    </service>
    <service verb="generate" noun="OrderIdsByTagFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate orderIds by tag feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                    <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                </entity-find-one>
                <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                <else>
                    <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="orderIdsByTagResponse"/>
                <if condition="!orderIdsByTagResponse.response.orders.edges">
                    <return message="No orderIds found between ${queryParams.fromDate} and ${queryParams.thruDate} for tag [${queryParams.tag}]"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                        //json file
                        File feedFile = new File(jsonFilePath)
                        if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                        JsonFactory jfactory = new JsonFactory()

                        /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                        try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                            jGenerator.writeStartArray()
                </script>
                <set field="orderIdsByTag" from="orderIdsByTagResponse.response.orders.edges"/>
                <iterate list="orderIdsByTag" entry="orderMap">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderMap.node)
                    </script>
                </iterate>
                <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.error("Error preparing OrderIdsByTag Feed file", e)
                    }
                </script>
                <if condition="relatedSystemMessageType">
                    <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                </if>
                <set field="hasNextPage" from="orderIdsByTagResponse.response.orders.pageInfo.hasNextPage"/>
                <set field="cursor" from="orderIdsByTagResponse.response.orders.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="OrderRestJsonFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="sendSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="sendSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="sendSmrParam">
                <set field="sendSmrId" from="sendSmrParam.parameterValue"/>
            </if>

            <if condition="sendSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="sendSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="tagsParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="tagsToAdd"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="tagsParam">
                <set field="tagsToAdd" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(tagsParam.parameterValue, List.class)"/>
            </if>
            <log message="tagsToAdd: ${tagsToAdd}"/>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="orders" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!orders">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <log message="jsonFilePath: ${jsonFilePath}"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    ec.logger.info("jsonFilePath:" +jsonFilePath)
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <log message="Orders: ${orders}"/>
            <iterate list="orders" entry="order">
                <set field="orderId" from="order.id.substring(order.id.lastIndexOf('/')+1)"/>
                <set field="endPoint" value="orders/${orderId}.json"/>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, endPoint:endPoint,
                        requestType:'GET', contentType:'application/json']" out-map="orderDetailsResponse" transaction="force-new" ignore-error="true"/>

                <if condition="orderDetailsResponse.statusCode != 200">
                    <log level="warn" message="System message from SystemMessageRemote with ID
                    ${systemMessageRemoteId} sent error response ${orderDetailsResponse.statusCode}: ${orderDetailsResponse.response}"/>
                </if>

                <if condition="orderDetailsResponse.response">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetailsResponse.response.order)
                    </script>

                    <script>
                        queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/UpdateOrderTags.ftl", "")
                    </script>
                    <if condition="tagsToAdd">
                        <set field="tags" from="order.tags"/>
                        <script>tags.addAll(tagsToAdd)</script>
                        <log message="tags: ${tags}"/>
                        <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText,
                        variables:[input:[id: order.id, tags: tags]]]" out-map="updateTagsResult" transaction="force-new" ignore-error="true"/>
                    </if>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Order Rest Json Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:sendSmrId,
                                       messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>
        </actions>
    </service>
    <service verb="queue" noun="FeedSystemMessage" authenticate="anonymous-all">
        <description>
            This is a generic service to queue a feed generation system message.
            Default behaviour is to generate an ad-hoc feed (runAsBatch=false) as needed with additionalParameters map containing any additional filter parameters.
            To generate the feed as a batch process create a ServiceJob with systemMessageTypeId, systemMessageRemoteId and runAsBatch=true.
        </description>
        <in-parameters>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="fromDate"/>
            <parameter name="thruDate"/>
            <parameter name="fromDateLabel"/>
            <parameter name="thruDateLabel"/>
            <parameter name="additionalParameters" type="Map"/>
            <parameter name="runAsBatch" type="Boolean" default-value="false"/>
        </in-parameters>
        <actions>
            <set field="queryParams" from="[:]"/>
            <if condition="additionalParameters">
                <set field="queryParams" from="additionalParameters"/>
            </if>
            <set field="queryParams.fromDateLabel" from="fromDateLabel"/>
            <set field="queryParams.thruDateLabel" from="thruDateLabel"/>
            <if condition="runAsBatch">
                <if condition="!fromDate">
                    <entity-find entity-name="moqui.service.message.SystemMessage" list="systemMessageList" limit="1">
                        <econdition field-name="systemMessageTypeId" from="systemMessageTypeId"/>
                        <econdition field-name="systemMessageRemoteId" from="systemMessageRemoteId"/>
                        <econdition field-name="statusId" value="SmsgSent"/>
                        <econdition field-name="messageDate" operator="is-not-null"/>
                        <order-by field-name="-messageDate"/>
                    </entity-find>
                    <if condition="systemMessageList">
                        <set field="fromDate" from="systemMessageList[0].messageDate" type="String"/>
                    </if>
                </if>
                <set field="thruDate" from="ec.user.nowTimestamp" type="String"/>
            </if>
            <if condition="fromDate">
                <set field="fromZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(fromDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.fromDate" from="fromZdtUTC.toString()"/>
            </if>
            <if condition="thruDate">
                <set field="thruZdtUTC" from="java.time.ZonedDateTime.ofInstant(Timestamp.valueOf(thruDate).toInstant(), java.time.ZoneId.of('UTC'))"/>
                <set field="queryParams.thruDate" from="thruZdtUTC.toString()"/>
            </if>
            <log message="queryParams: ${queryParams}"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                          in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                                       messageText:org.moqui.impl.context.ContextJavaUtil.jacksonMapper.writeValueAsString(queryParams),  sendNow:true]"
                          out-map="queueSystemMessageOut"/>

            <if condition="runAsBatch">
                <service-call name="update#moqui.service.message.SystemMessage" in-map="[systemMessageId:queueSystemMessageOut.systemMessageId, messageDate:thruDate]"/>
            </if>
        </actions>
    </service>
    <service verb="generate" noun="UpdatedOrderIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate updated orderIds feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                    <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                </entity-find-one>
                <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                <else>
                    <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="updatedOrderIdsResponse"/>
                <if condition="!updatedOrderIdsResponse.response.orders.edges">
                    <return message="No orderIds found between ${queryParams.fromDate} and ${queryParams.thruDate} for tag [${queryParams.tag}]"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                            jGenerator.writeStartArray()
                </script>
                <set field="updatedOrderIds" from="updatedOrderIdsResponse.response.orders.edges"/>
                <iterate list="updatedOrderIds" entry="orderMap">
                    <script>
                            new ObjectMapper()
                                .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                                .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderMap.node)
                    </script>
                </iterate>
                <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.error("Error preparing UpdatedOrderIds Feed file", e)
                    }
                </script>
                <if condition="relatedSystemMessageType">
                    <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                </if>
                <set field="hasNextPage" from="updatedOrderIdsResponse.response.orders.pageInfo.hasNextPage"/>
                <set field="cursor" from="updatedOrderIdsResponse.response.orders.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="OrderUpdatesFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="sendSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="sendSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="sendSmrParam">
                <set field="sendSmrId" from="sendSmrParam.parameterValue"/>
            </if>

            <if condition="sendSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="sendSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="orders" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!orders">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <log message="jsonFilePath: ${jsonFilePath}"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="orders" entry="order">
                <service-call name="co.hotwax.shopify.order.ShopifyOrderServices.get#OrderDetails" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id]"
                              out-map="orderDetailsResponse" ignore-error="true" transaction="force-new"/>

                <if condition="orderDetailsResponse.orderDetail">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetailsResponse.orderDetail)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Order Rest Json Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:sendSmrId,
                                       messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>
        </actions>
    </service>
    <service verb="generate" noun="CreatedProductIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate created productIds feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="createdProductIdsResponse"/>
                <if condition="!createdProductIdsResponse.response.products.edges">
                    <return message="No productIds found between ${queryParams.fromDate} and ${queryParams.thruDate}"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                    jGenerator.writeStartArray()
                </script>
                <set field="createdProductIds" from="createdProductIdsResponse.response.products.edges.node"/>
                <iterate list="createdProductIds" entry="productMap">
                    <set field="productMap" from="productMap + [namespaces:queryParams.namespaces]"/>
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, productMap)
                    </script>
                </iterate>
                <script>
                    jGenerator.writeEndArray()
                    }
                    } catch (IOException e) {
                    logger.error("Error preparing CreatedProductIds Feed file", e)
                    }
                </script>
                <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:'GenerateCreatedProductsFeed', messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, parentMessageId:systemMessageId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                <set field="hasNextPage" from="createdProductIdsResponse.response.products.pageInfo.hasNextPage"/>
                <set field="cursor" from="createdProductIdsResponse.response.products.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="CreatedProductsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="products" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!products">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <log message="jsonFilePath: ${jsonFilePath}"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="products" entry="product">
                <service-call name="co.hotwax.shopify.product.ShopifyProductServices.get#ProductDetails" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyProductId:product.id, namespaces:product.namespaces]"
                              out-map="productDetailsResponse" ignore-error="true" transaction="force-new"/>

                <if condition="productDetailsResponse.productDetail">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, productDetailsResponse.productDetail)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Created Products Feed file", e)
                }
            </script>

            <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:'ShopifyNewProductsFeed', messageText:jsonFilePathRef,
                          systemMessageRemoteId:systemMessage.systemMessageRemoteId, parentMessageId:systemMessageId, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" async="true"/>
        </actions>
    </service>
    <service verb="generate" noun="UpdatedProductIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate updated productIds feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="updatedProductIdsResponse"/>
                <if condition="!updatedProductIdsResponse.response.products.edges">
                    <return message="No productIds found between ${queryParams.fromDate} and ${queryParams.thruDate}"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                        //json file
                        File feedFile = new File(jsonFilePath)
                        if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                        JsonFactory jfactory = new JsonFactory()

                        /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                        try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                            jGenerator.writeStartArray()
                </script>
                <set field="updatedProductIds" from="updatedProductIdsResponse.response.products.edges.node"/>
                <iterate list="updatedProductIds" entry="productMap">
                    <set field="productMap" from="productMap + [namespaces:queryParams.namespaces]"/>
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, productMap)
                    </script>
                </iterate>
                <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.error("Error preparing UpdatedProductIds Feed file", e)
                    }
                </script>

                <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:'GenerateProductUpdatesFeed', messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, parentMessageId:systemMessage.systemMessageId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" async="true"/>
                <set field="hasNextPage" from="updatedProductIdsResponse.response.products.pageInfo.hasNextPage"/>
                <set field="cursor" from="updatedProductIdsResponse.response.products.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="ProductUpdatesFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="products" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!products">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <log message="jsonFilePath: ${jsonFilePath}"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="products" entry="product">
                <service-call name="co.hotwax.shopify.product.ShopifyProductServices.get#ProductDetails" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyProductId:product.id, namespaces:product.namespaces]"
                              out-map="productDetailsResponse" ignore-error="true" transaction="force-new"/>

                <if condition="productDetailsResponse.productDetail">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, productDetailsResponse.productDetail)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Updated Products Feed file", e)
                }
            </script>

            <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:'ShopifyProductUpdatesFeed', messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, parentMessageId:systemMessage.systemMessageId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" async="true"/>
        </actions>
    </service>
    <service verb="generate" noun="NewOrderIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate new orderIds feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                    <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                </entity-find-one>
                <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                <else>
                    <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="newOrderIdsResponse"/>
                <if condition="!newOrderIdsResponse.response.orders.edges">
                    <return message="No orderIds found between ${queryParams.fromDate} and ${queryParams.thruDate} for tag [${queryParams.tag}]"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                        //json file
                        File feedFile = new File(jsonFilePath)
                        if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                        JsonFactory jfactory = new JsonFactory()

                        /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                        try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                            jGenerator.writeStartArray()
                </script>
                <set field="newOrderIds" from="newOrderIdsResponse.response.orders.edges.node"/>
                <iterate list="newOrderIds" entry="orderMap">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderMap)
                    </script>
                </iterate>
                <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.error("Error preparing UpdatedOrderIds Feed file", e)
                    }
                </script>
                <if condition="relatedSystemMessageType">
                    <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                </if>
                <set field="hasNextPage" from="newOrderIdsResponse.response.orders.pageInfo.hasNextPage"/>
                <set field="cursor" from="newOrderIdsResponse.response.orders.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="NewOrdersFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="sendSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="sendSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="sendSmrParam">
                <set field="sendSmrId" from="sendSmrParam.parameterValue"/>
            </if>

            <if condition="sendSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="sendSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="orders" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!orders">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <log message="jsonFilePath: ${jsonFilePath}"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="orders" entry="order">
                <service-call name="co.hotwax.shopify.order.ShopifyOrderServices.get#OrderDetails" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id, includeLineItems:false]"
                              out-map="orderDetailsResponse" ignore-error="true" transaction="force-new"/>

                <if condition="orderDetailsResponse.orderDetail">
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetailsResponse.orderDetail)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing New Orders Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:sendSmrId,
                                       messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>
        </actions>
    </service>
    <service verb="generate" noun="UpdatedAgreementOrderIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate updated agreement orderIds feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>
            <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                    <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                </entity-find-one>
                <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                <else>
                    <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="updatedOrderIdsResponse"/>
                <if condition="!updatedOrderIdsResponse.response.orders.edges">
                    <return message="No orderIds found between ${queryParams.fromDate} and ${queryParams.thruDate} for tag [${queryParams.tag}]"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                        //json file
                        File feedFile = new File(jsonFilePath)
                        if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                        JsonFactory jfactory = new JsonFactory()

                        /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                        try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                            jGenerator.writeStartArray()
                </script>
                <set field="updatedOrderIds" from="updatedOrderIdsResponse.response.orders.edges.node"/>
                <iterate list="updatedOrderIds" entry="orderMap">
                    <set field="orderMap" from="orderMap + queryParams"/>
                    <script>
                            new ObjectMapper()
                            .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                            .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderMap)
                    </script>
                </iterate>
                <script>
                            jGenerator.writeEndArray()
                        }
                    } catch (IOException e) {
                        logger.error("Error preparing UpdatedOrderIds Feed file", e)
                    }
                </script>
                <if condition="relatedSystemMessageType">
                    <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                </if>
                <set field="hasNextPage" from="updatedOrderIdsResponse.response.orders.pageInfo.hasNextPage"/>
                <set field="cursor" from="updatedOrderIdsResponse.response.orders.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="OrderAgreementUpdatesFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="sendSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="sendSmrId"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <if condition="sendSmrParam">
                <set field="sendSmrId" from="sendSmrParam.parameterValue"/>
            </if>

            <if condition="sendSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="sendSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="orders" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!orders">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="orders" entry="order">
                <service-call name="co.hotwax.shopify.order.ShopifyOrderServices.get#OrderAgreements" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id, queryParams:[fromDate:order.fromDate, thruDate:order.thruDate]]"
                              out-map="orderAgreementsResponse" ignore-error="true" transaction="force-new"/>

                <if condition="orderAgreementsResponse.agreements">
                    <set field="orderDetail" from="[:]"/>
                    <set field="orderDetail.id" from="order.id"/>
                    <set field="orderDetail.name" from="order.name"/>
                    <set field="orderDetail.agreements" from="orderAgreementsResponse.agreements"/>
                    <script>
                        new ObjectMapper()
                        .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                        .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetail)
                    </script>
                </if>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Order Agreement Updates Feed file", e)
                }
            </script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                              in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:sendSmrId,
                                       messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                              out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>
        </actions>
    </service>
    <service verb="generate" noun="FulfillmentOrderIdsFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate the Fulfillment Order Ids Feed</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>queryText = ec.resourceFacade.template(systemMessage.sendPath, "")</script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="fulfillmentOrderIdsResponse"/>
                <if condition="!fulfillmentOrderIdsResponse.response.fulfillmentOrders.edges">
                    <return message="No fulfillmentOrderIds found between ${queryParams.fromDate} and ${queryParams.thruDate}"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                        //json file
                        File feedFile = new File(jsonFilePath)
                        if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                        JsonFactory jfactory = new JsonFactory()

                        /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                        try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                            JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                            jGenerator.writeStartArray()
                </script>
                <set field="fulfillmentOrderIds" from="fulfillmentOrderIdsResponse.response.fulfillmentOrders.edges.node"/>
                <iterate list="fulfillmentOrderIds" entry="fulfillmentOrderMap">
                    <script>
                        new ObjectMapper()
                            .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                            .writerWithDefaultPrettyPrinter()
                            .writeValue(jGenerator, fulfillmentOrderMap)
                    </script>
                </iterate>
                <script>
                    jGenerator.writeEndArray()
                    }
                    } catch (IOException e) {
                        logger.error("Error preparing CreatedProductIds Feed file", e)
                    }
                </script>
                <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:'GenerateFulfillmentOrdersFeed', messageText:jsonFilePathRef,
                              systemMessageRemoteId:systemMessage.systemMessageRemoteId, parentMessageId:systemMessageId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" transaction="force-new" ignore-error="true"/>
                <set field="hasNextPage" from="fulfillmentOrderIdsResponse.response.fulfillmentOrders.pageInfo.hasNextPage"/>
                <set field="cursor" from="fulfillmentOrderIdsResponse.response.fulfillmentOrders.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="FulfillmentOrdersFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <set field="fileText" from="ec.resource.getLocationReference(systemMessage.messageText).getText()"/>
            <set field="fulfillmentOrdersList" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(fileText, List.class)"/>

            <if condition="!fulfillmentOrdersList">
                <return type="warning" message="System message [${systemMessageId}] for Type [${systemMessage?.systemMessageTypeId}] has messageText [${systemMessage.messageText}], with ReturnedOrderIdsFeed file having incorrect data and may contain null, not generating order returns feed file."/>
            </if>

            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.sendPath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                    dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File feedFile = new File(jsonFilePath)
                    if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>
            <iterate list="fulfillmentOrdersList" entry="fulfillmentOrder">
                <service-call name="co.hotwax.shopify.fulfillment.ShopifyFulfillmentServices.get#FulfillmentOrderDetails" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, fulfillmentOrderId:fulfillmentOrder.id]"
                              out-map="fufillmentOrderDetailsResponse" ignore-error="true" transaction="force-new"/>
                <if condition="fufillmentOrderDetailsResponse.fulfillmentOrderDetail">
                    <script>
                        new ObjectMapper()
                            .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                            .writerWithDefaultPrettyPrinter()
                            .writeValue(jGenerator, fufillmentOrderDetailsResponse.fulfillmentOrderDetail)
                    </script>
                </if>
            </iterate>
            <script>
                jGenerator.writeEndArray()
                }
                } catch (IOException e) {
                    logger.error("Error preparing Created Products Feed file", e)
                }
            </script>

            <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:'ShopifyFulfillmentOrdersFeed', messageText:jsonFilePathRef,
                      systemMessageRemoteId:systemMessage.systemMessageRemoteId, parentMessageId:systemMessageId, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" async="true"/>
        </actions>
    </service>
    <service verb="generate" noun="ProductVariantUpdatesFeed" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Generate Product Variant Updates Feed.</description>
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageAndType" value-field="systemMessage"/>

            <set field="queryParams" from="org.moqui.impl.context.ContextJavaUtil.jacksonMapper.readValue(systemMessage.messageText, Map.class)"/>

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
            </script>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template(systemMessage.sendPath, "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, queryText:queryText]" out-map="updatedProductVariantsResponse"/>
                <if condition="!updatedProductVariantsResponse.response.productVariants.edges">
                    <return message="No productIds found between ${queryParams.fromDate} and ${queryParams.thruDate}"/>
                </if>
                <set field="nowDate" from="ec.user.nowTimestamp"/>
                <set field="jsonFilePathRef" from="ec.resource.expand(systemMessage.receivePath, null,
                    [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>
                <script>
                    try {
                        //json file
                        File feedFile = new File(jsonFilePath)
                        if (!feedFile.parentFile.exists()) feedFile.parentFile.mkdirs()
                        JsonFactory jfactory = new JsonFactory()

                        /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                        try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, feedFile);
                            JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                            jGenerator.writeStartArray()
                </script>
                <set field="updatedProductVariants" from="updatedProductVariantsResponse.response.productVariants.edges.node"/>
                <iterate list="updatedProductVariants" entry="productMap">
                    <set field="productMap" from="productMap"/>
                    <script>
                        new ObjectMapper()
                            .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                            .writerWithDefaultPrettyPrinter().writeValue(jGenerator, productMap)
                    </script>
                </iterate>
                <script>
                    jGenerator.writeEndArray()
                    }
                    } catch (IOException e) {
                        logger.error("Error preparing Product Variant Updates Feed file", e)
                    }
                </script>

                <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage" in-map="[systemMessageTypeId:'ShopifyVariantUpdatesFeed', messageText:jsonFilePathRef,
                        systemMessageRemoteId:systemMessage.systemMessageRemoteId, parentMessageId:systemMessage.systemMessageId, remoteMessageId:jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1)]" async="true"/>
                <set field="hasNextPage" from="updatedProductVariantsResponse.response.productVariants.pageInfo.hasNextPage"/>
                <set field="cursor" from="updatedProductVariantsResponse.response.productVariants.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>
</services>