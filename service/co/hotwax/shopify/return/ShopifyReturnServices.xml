<?xml version="1.0" encoding="UTF-8"?>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://moqui.org/xsd/service-definition-3.xsd">
    <service verb="get" noun="RefundLineItems" authenticate="anonymous-all">
        <description>Integrates with Shopify GraphQL Refund API to get associated refund line items.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyRefundId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundLineItems" type="List"/>
        </out-parameters>
        <actions>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <set field="refundLineItems" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/RefundLineItemsByIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="refundLineItemsResponse"/>
                <if condition="!refundLineItemsResponse.response.refund">
                    <return message="No Shopify refund found for id: ${shopifyRefundId}"/>
                </if>
                <if condition="refundLineItemsResponse.response.refund.refundLineItems.edges">
                    <script>refundLineItems.addAll(refundLineItemsResponse.response.refund.refundLineItems.edges.node)</script>
                </if>
                <set field="hasNextPage" from="refundLineItemsResponse.response.refund.refundLineItems.pageInfo.hasNextPage"/>
                <set field="cursor" from="refundLineItemsResponse.response.refund.refundLineItems.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>

    <service verb="get" noun="RefundShippingLines" authenticate="anonymous-all">
        <description>Integrates with Shopify GraphQL Refund API to get associated refund shipping lines.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyRefundId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundShippingLines" type="List"/>
        </out-parameters>
        <actions>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <set field="refundShippingLines" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/RefundShippingLinesByIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="refundShippingLinesResponse"/>
                <if condition="!refundShippingLinesResponse.response.refund">
                    <return message="No Shopify refund found for id: ${shopifyRefundId}"/>
                </if>
                <if condition="refundShippingLinesResponse.response.refund.refundShippingLines.edges">
                    <script>refundShippingLines.addAll(refundShippingLinesResponse.response.refund.refundShippingLines.edges.node)</script>
                </if>
                <set field="hasNextPage" from="refundShippingLinesResponse.response.refund.refundShippingLines.pageInfo.hasNextPage"/>
                <set field="cursor" from="refundShippingLinesResponse.response.refund.refundShippingLines.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>

    <service verb="get" noun="RefundTransactions" authenticate="anonymous-all">
        <description>Integrates with Shopify GraphQL Refund API to get associated transactions.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyRefundId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundTransactions" type="Map"/>
        </out-parameters>
        <actions>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <set field="refundTransactions" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/RefundTransactionsByIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="refundTransactionsResponse"/>
                <if condition="!refundTransactionsResponse.response.refund">
                    <return message="No Shopify refund found for id: ${refundId}"/>
                </if>
                <if condition="refundTransactionsResponse.response.refund.transactions.edges">
                    <script>refundTransactions.addAll(refundTransactionsResponse.response.refund.transactions.edges.node)</script>
                </if>
                <set field="hasNextPage" from="refundTransactionsResponse.response.refund.transactions.pageInfo.hasNextPage"/>
                <set field="cursor" from="refundTransactionsResponse.response.refund.transactions.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>

    <service verb="get" noun="ReturnLineItemsByRefund" authenticate="anonymous-all">
        <description>Integrates with Shopify GraphQL Refund API to return a list of return line items associated with.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyRefundId" required="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundDetail" type="Map"/>
        </out-parameters>
        <actions>
            <set field="refundDetail" from="[:]"/>
            <set field="returnLineItems" from="[]"/>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/ReturnLineItemsByRefundQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="returnLineItemsResponse"/>
                <if condition="!returnLineItemsResponse.response.node">
                    <return message="No Shopify refund found for id: ${refundId}"/>
                </if>
                <if condition="!returnLineItemsResponse.response.node.return">
                    <return message="No associated return found for Shopify refundId: ${refundId}"/>
                </if>
                <if condition="!refundDetail.shopifyRefundId">
                    <set field="refundDetail.shopifyRefundId" from="returnLineItemsResponse.response.node.id"/>
                </if>
                <if condition="!refundDetail.shopifyOrderId">
                    <set field="refundDetail.shopifyOrderId" from="returnLineItemsResponse.response.node.order.id"/>
                </if>
                <if condition="!refundDetail.shopifyReturnId">
                    <set field="refundDetail.shopifyReturnId" from="returnLineItemsResponse.response.node.return.id"/>
                </if>
                <iterate list="returnLineItemsResponse.response.node.return.returnLineItems.edges" entry="returnLineItem">
                    <set field="returnReasonMap" from="[:]"/>
                    <set field="returnReasonMap.shopifyLineItemId" from="returnLineItem.node.fulfillmentLineItem.lineItem.id"/>
                    <set field="returnReasonMap.returnReason" from="returnLineItem.node.returnReason"/>
                    <set field="returnReasonMap.returnReasonNote" from="returnLineItem.node.returnReasonNote"/>
                    <set field="returnReasonMap.customerNote" from="returnLineItem.node.customerNote"/>
                    <script>returnLineItems.add(returnReasonMap)</script>
                </iterate>
                <set field="hasNextPage" from="returnLineItemsResponse.response.node.return.returnLineItems.pageInfo.hasNextPage"/>
                <set field="cursor" from="returnLineItemsResponse.response.node.return.returnLineItems.pageInfo.endCursor"/>
            </while>
            <if condition="returnLineItems">
                <set field="refundDetail.returnLineItems" from="returnLineItems"/>
            </if>
        </actions>
    </service>

    <service verb="get" noun="RefundOrderAdjustments" authenticate="anonymous-all">
        <description>Integrates with Shopify Rest Refund API to get associated order adjustments.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyRefundId" required="true"/>
            <parameter name="shopifyOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundDetail" type="Map"/>
        </out-parameters>
        <actions>
            <set field="refundDetail" from="[:]"/>
            <set field="endPoint" value="orders/${shopifyOrderId}/refunds/${shopifyRefundId}.json?fields=id,order_id,user_id,order_adjustments"/>
            <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, endPoint:endPoint,
                        requestType:'GET', contentType:'application/json']" out-map="refundOrderAdjustmentsResponse"/>

            <if condition="refundOrderAdjustmentsResponse.statusCode != 200">
                <return type="warning" message="System message from SystemMessageRemote with ID
                    ${systemMessageRemoteId} sent error response ${refundOrderAdjustmentsResponse.statusCode}: ${refundOrderAdjustmentsResponse.response}"/>
            </if>
            <if condition="!refundOrderAdjustmentsResponse.response.refund">
                <return message="No Shopify refund found for id: ${refundId}"/>
            </if>
            <set field="refundDetail.shopifyRefundId" from="refundOrderAdjustmentsResponse.response.refund.id"/>
            <set field="refundDetail.shopifyOrderId" from="refundOrderAdjustmentsResponse.response.refund.order_id"/>
            <set field="refundDetail.shopifyUserId" from="refundOrderAdjustmentsResponse.response.refund.user_id"/>
            <set field="refundDetail.orderAdjustments" from="refundOrderAdjustmentsResponse.response.refund.order_adjustments"/>
        </actions>
    </service>

    <service verb="get" noun="RefundsByReturnId" authenticate="anonymous-all">
        <description>Get Shopify Refund Details</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="returnId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundDetails" type="List"/>
        </out-parameters>
        <actions>
            <set field="refundDetails" from="[]"/>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/RefundIdsByReturnIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="refundResponse"/>
                <if condition="!refundResponse.response.node">
                    <return type="warning" message="No Shopify return found for id: ${returnId}"/>
                </if>
                <!-- Getting all the refundId associated with returnId-->
                <set field="refundsList" from="[]"/>
                <if condition="refundResponse.response.node.refunds.edges">
                    <script>refundsList.addAll(refundResponse.response.node.refunds.edges.node)</script>
                </if>
                <iterate list="refundsList" entry="shopifyRefund">
                    <set field="refundDetail" from="[:]"/>
                    <set field="shopifyRefundId" from="shopifyRefund.id"/>
                    <set field="refundDetail.id" from="shopifyRefundId"/>
                    <set field="refundDetail.createdAt" from="shopifyRefund.createdAt"/>
                    <set field="refundDetail.totalRefundedSet" from="shopifyRefund.totalRefundedSet"/>
                    <!-- Getting refund line items for each refundId-->
                    <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundLineItems" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:shopifyRefundId]"
                                  out-map="refundLineItemsResponse"/>
                    <set field="refundDetail.refundLineItems" from="refundLineItemsResponse.refundLineItems"/>
                    <!-- Getting refund transactions for each refundId-->
                    <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundTransactions" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:shopifyRefundId]"
                                  out-map="refundTransactionsResponse"/>
                    <set field="refundDetail.transactions" from="refundTransactionsResponse.refundTransactions"/>
                    <script>refundDetails.add(refundDetail)</script>
                </iterate>
                <set field="hasNextPage" from="refundResponse.response.node.refunds.pageInfo.hasNextPage"/>
                <set field="cursor" from="refundResponse.response.node.refunds.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>

    <service verb="get" noun="ReverseFulfillmentOrders" authenticate="anonymous-all">
        <description>Get reverse fulfillment orders for a given Return Id</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="returnId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="reverseFulfillmentOrders"/>
        </out-parameters>
        <actions>
            <set field="reverseFulfillmentOrders" from="[]"/>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/ReverseFulfillmentOrdersByIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="reverseFulfillmentOrderResponse"/>
                <if condition="!reverseFulfillmentOrderResponse.response.node">
                    <return type="warning" message="No Shopify return found for id: ${returnId}"/>
                </if>
                <if condition="reverseFulfillmentOrderResponse.response.node.reverseFulfillmentOrders.edges">
                    <script>reverseFulfillmentOrders.addAll(reverseFulfillmentOrderResponse.response.node.reverseFulfillmentOrders.edges.node)</script>
                </if>
                <set field="hasNextPage" from="reverseFulfillmentOrderResponse.response.node.reverseFulfillmentOrders.pageInfo.hasNextPage"/>
                <set field="cursor" from="reverseFulfillmentOrderResponse.response.node.reverseFulfillmentOrders.pageInfo.endCursor"/>
            </while>
            <iterate list="reverseFulfillmentOrders" entry="reverseFulfillmentOrder">
                <set field="reverseFulfillmentOrderId" from="reverseFulfillmentOrder.id"/>
                <set field="hasNextPage" value="true"/>
                <set field="cursor" value=""/>
                <set field="lineItems" from="[]"/>
                <while condition="hasNextPage">
                    <script>
                        queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/ReverseFulfillmentOrderLineItemsByIdQuery.ftl", "")
                    </script>
                    <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="lineItemResponse"/>
                    <if condition="lineItemResponse.response.node.lineItems.edges">
                        <script>lineItems.addAll(lineItemResponse.response.node.lineItems.edges.node)</script>
                    </if>
                    <set field="hasNextPage" from="lineItemResponse.response.node.lineItems.pageInfo.hasNextPage"/>
                    <set field="cursor" from="lineItemResponse.response.node.lineItems.pageInfo.endCursor"/>
                </while>
                <set field="reverseFulfillmentOrder.lineItems" from="lineItems"/>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="ReturnDetails">
        <description>Get return details for a given Return Id</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="returnId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="returnDetail"/>
        </out-parameters>
        <actions>
            <script>
                queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/ReturnHeaderByIdQuery.ftl", "")
            </script>
            <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="returnResponse"/>
            <if condition="!returnResponse.response.node">
                <return type="warning" message="No Shopify return found for id: ${returnId}"/>
            </if>
            <set field="returnDetail" from="returnResponse.response.node"/>
            <!-- Getting return line items detail-->
            <set field="hasNextPage" type="Boolean" value="true"/>
            <set field="returnLineItems" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/ReturnLineItemByIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="returnLineItemResponse"/>
                <if condition="returnLineItemResponse.response.node.returnLineItems.edges">
                    <script>returnLineItems.addAll(returnLineItemResponse.response.node.returnLineItems.edges.node)</script>
                </if>
                <set field="hasNextPage" from="returnLineItemResponse.response.node.returnLineItems.pageInfo.hasNextPage"/>
                <set field="cursor" from="returnLineItemResponse.response.node.returnLineItems.pageInfo.endCursor"/>
            </while>
            <set field="returnDetail.returnLineItems" from="returnLineItems"/>
            <!-- Getting exchange line items detail-->
            <set field="hasNextPage" value="true"/>
            <set field="cursor" value=""/>
            <set field="exchangeLineItems" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/ExchangeLineItemByIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="exchangeLineItemResponse"/>
                <if condition="exchangeLineItemResponse.response.node.exchangeLineItems.edges">
                    <script>exchangeLineItems.addAll(exchangeLineItemResponse.response.node.exchangeLineItems.edges.node)</script>
                </if>
                <set field="hasNextPage" from="exchangeLineItemResponse.response.node.exchangeLineItems.pageInfo.hasNextPage"/>
                <set field="cursor" from="exchangeLineItemResponse.response.node.exchangeLineItems.pageInfo.endCursor"/>
            </while>
            <set field="returnDetail.exchangeLineItems" from="exchangeLineItems"/>
            <!-- Getting refund details for returnId -->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundsByReturnId" in-map="[systemMessageRemoteId:systemMessageRemoteId, returnId:returnId]" out-map="refundDetails"/>
            <set field="returnDetail.refunds" from="refundDetails.refundDetails"/>

            <!-- Getting reverse fulfillment orders for returnId -->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#ReverseFulfillmentOrders" in-map="[systemMessageRemoteId:systemMessageRemoteId, returnId:returnId]" out-map="reverseFulfillmentOrdersResponse"/>
            <set field="returnDetail.reverseFulfillmentOrders" from="reverseFulfillmentOrdersResponse.reverseFulfillmentOrders"/>
        </actions>
    </service>

    <service verb="get" noun="RefundDetails">
        <description>Get refund details for a given Return Id</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="refundId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundDetail"/>
        </out-parameters>
        <actions>
            <script>
                queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/RefundHeaderByIdQuery.ftl", "")
            </script>
            <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="refundResponse"/>
            <if condition="!refundResponse.response.node">
                <return type="warning" message="No Shopify refund found for id: ${refundId}"/>
            </if>
            <set field="refundDetail" from="refundResponse.response.node"/>

            <!-- Getting refund Line Items for refundId-->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundLineItems" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:refundId]" out-map="refundLineItemsResponse"/>
            <set field="refundDetail.refundLineItems" from="refundLineItemsResponse.refundLineItems"/>

            <!-- Getting transactions for refundId-->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundTransactions" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:refundId]" out-map="refundTransactionsResponse"/>
            <set field="refundDetail.transactions" from="refundTransactionsResponse.refundTransactions"/>

            <!-- Getting refund shipping Lines for refundId-->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundShippingLines" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:refundId]" out-map="refundShippingLinesResponse"/>
            <set field="refundDetail.refundShippingLines" from="refundShippingLinesResponse.refundShippingLines"/>
        </actions>
    </service>

    <service verb="get" noun="ReturnsByOrderId">
        <description>Get all returns detail for a given shopify orderId</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderReturns"/>
        </out-parameters>
        <actions>
            <set field="orderReturns" from="[:]"/>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <set field="returns" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/ReturnsByOrderIDQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="returnResponse"/>
                <if condition="!returnResponse.response.node">
                    <return type="warning" message="No Shopify order found for id: ${shopifyOrderId}"/>
                </if>
                <!-- Getting all the returnId for the shopifyOrderId-->
                <set field="returnIdList" from="[]"/>
                <if condition="returnResponse.response.node.returns.edges">
                    <script>returnIdList.addAll(returnResponse.response.node.returns.edges.node.id)</script>
                </if>
                <!-- Getting return details for each returnId-->
                <iterate list="returnIdList" entry="returnId">
                    <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#ReturnDetails" in-map="[systemMessageRemoteId:systemMessageRemoteId, returnId:returnId]" out-map="returnDetails"/>
                    <script>returns.addAll(returnDetails.returnDetail)</script>
                </iterate>
                <set field="hasNextPage" from="returnResponse.response.node.returns.pageInfo.hasNextPage"/>
                <set field="cursor" from="returnResponse.response.node.returns.pageInfo.endCursor"/>
            </while>
            <set field="orderReturns.id" from="returnResponse.response.node.id"/>
            <set field="orderReturns.name" from="returnResponse.response.node.name"/>
            <set field="orderReturns.returns" from="returns"/>
        </actions>
    </service>
    <service verb="get" noun="RefundsByOrderId">
        <description>Get all returns detail for a given shopify orderId</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderRefunds"/>
        </out-parameters>
        <actions>
            <set field="orderRefunds" from="[:]"/>
            <set field="refunds" from="[]"/>
            <script>
                queryText = ec.resourceFacade.template("dbresource://shopify/template/graphQL/RefundIdsByOrderIdQuery.ftl", "")
            </script>
            <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="refundResponse"/>
            <if condition="!refundResponse.response.node">
                <return type="warning" message="No Shopify order found for id: ${shopifyOrderId}"/>
            </if>
            <if condition="refundResponse.response.node.refunds">
                <iterate list="refundResponse.response.node.refunds" entry="refund">
                    <set field="refundIdString" from="refund.id"/>
                    <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundDetails" in-map="[systemMessageRemoteId:systemMessageRemoteId, refundId:refundIdString]" out-map="refundDetails"/>
                    <script>refunds.add(refundDetails.refundDetail)</script>
                </iterate>
            </if>
            <set field="orderRefunds.refunds" from="refunds"/>
        </actions>
    </service>
    <service verb="get" noun="ExchangesByOrderId">
        <description>Get all exchanges detail for a given shopify orderId</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderExchanges"/>
        </out-parameters>
        <actions>
            <set field="orderExchanges" from="[:]"/>
            <set field="hasNextPage" type="Boolean" value="true"/>
            <set field="exchanges" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/ExchangesByOrderIDQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="exchangeResponse"/>
                <if condition="!exchangeResponse.response.node">
                    <return type="warning" message="No Shopify order found for id: ${shopifyOrderId}"/>
                </if>
                <!-- Getting all the returnId for the shopifyOrderId-->
                <if condition="exchangeResponse.response.node.exchangeV2s.edges">
                    <script>exchanges.addAll(exchangeResponse.response.node.exchangeV2s.edges.node)</script>
                </if>
                <set field="hasNextPage" from="exchangeResponse.response.node.exchangeV2s.pageInfo.hasNextPage"/>
                <set field="cursor" from="exchangeResponse.response.node.exchangeV2s.pageInfo.endCursor"/>
            </while>
            <set field="orderExchanges.id" from="exchangeResponse.response.node.id"/>
            <set field="orderExchanges.name" from="exchangeResponse.response.node.name"/>
            <set field="orderExchanges.customer" from="exchangeResponse.response.node.customer"/>
            <set field="orderExchanges.originalTotalPriceSet" from="exchangeResponse.response.node.originalTotalPriceSet"/>
            <set field="orderExchanges.exchanges" from="exchanges"/>
        </actions>
    </service>

    <service verb="get" noun="OrderRefundAndReturnSummary">
        <!--  TODO description -->
        <description>Get refund agreements linked to a Shopify order</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <!--  TODO output structure? -->
            <parameter name="order" type="Map"/>
        </out-parameters>
        <actions>
            <set field="order" from="[:]"/>
            <log message="Fetching order level and refund/return for shopifyOrderId=${shopifyOrderId}"/>
            <set field="hasNextPage" value="true" type="Boolean"/>

            <!-- Preparing the order level details -->
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/OrderRefundAndReturnSummaryByOrderIdQuery.ftl", "")
                </script>

                <log message="Executing query: ${queryText}"/>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest"
                        in-map="[systemMessageRemoteId: systemMessageRemoteId, queryText: queryText]" out-map="responseMap"/>

                <log message="Received response: ${responseMap}"/>

                <if condition="!responseMap.response?.order">
                    <return type="warning" message="No Shopify order found for id: ${shopifyOrderId}"/>
                </if>
            <set field="order" from="responseMap.response.order"/>
        </actions>
    </service>

    <service verb="get" noun="RefundAgreements">
        <description>Get refund agreements linked to a Shopify order</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundAgreements" type="List"/>
        </out-parameters>
        <actions>
            <set field="refundAgreements" from="[]"/>
            <log message="Fetching refund agreements for shopifyOrderId=${shopifyOrderId}"/>
            <set field="hasNextPage" value="true" type="Boolean"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/OrderRefundAgreementsByOrderIdQuery.ftl", "")
                </script>

                <log message="Executing query: ${queryText}"/>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest"
                        in-map="[systemMessageRemoteId: systemMessageRemoteId, queryText: queryText]" out-map="responseMap"/>

                <log message="Received response: ${responseMap}"/>

                <if condition="!responseMap.response?.order">
                    <return type="warning" message="No Shopify order found for id: ${shopifyOrderId}"/>
                </if>

                <!-- Collect all the RefundAgreements in the list -->
                <if condition="responseMap.response.order?.agreements?.edges">
                    <script>refundAgreements.addAll(responseMap.response.order.agreements.edges.collect { it.node }.findAll { it.__typename == 'RefundAgreement' })</script>
                </if>

                <!-- Pagination -->
                <if condition="responseMap.response.order?.agreements?.pageInfo">
                    <set field="hasNextPage" from="responseMap.response.order.agreements.pageInfo.hasNextPage"/>
                    <set field="cursor" from="responseMap.response.order.agreements.pageInfo.endCursor"/>
                </if>
                <else>
                    <set field="hasNextPage" value="false"/>
                </else>
            </while>
        </actions>
    </service>

    <service verb="get" noun="RefundDetailsById">
        <description>Get refund details for a given Refund Id.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="refundId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="refundDetail" type="Map"/>
        </out-parameters>
        <actions>
            <set field="refundDetail" from="[:]"/>
            <!-- Getting refund Line Items for refundId-->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundLineItems" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:refundId]" out-map="refundLineItemsResponse"/>
            <set field="refundDetail.refundLineItems" from="refundLineItemsResponse.refundLineItems"/>

            <!-- Getting transactions for refundId-->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundTransactions" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:refundId]" out-map="refundTransactionsResponse"/>
            <set field="refundDetail.transactions" from="refundTransactionsResponse.refundTransactions"/>

            <!-- Getting refund shipping Lines for refundId-->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundShippingLines" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:refundId]" out-map="refundShippingLinesResponse"/>
            <set field="refundDetail.refundShippingLines" from="refundShippingLinesResponse.refundShippingLines"/>

            <!-- Getting order adjustment for refundId-->
            <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#OrderAdjustments" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyRefundId:refundId]" out-map="refundOrderAdjustmentResponse"/>
            <set field="refundDetail.orderAdjustments" from="refundOrderAdjustmentResponse.orderAdjustments"/>
        </actions>
    </service>

    <service verb="get" noun="OrderAdjustments">
        <description>Get order adjustments linked to a Shopify refund</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyRefundId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderAdj"/>
        </out-parameters>
        <actions>
            <set field="orderAdj" from="[]"/>
            <set field="hasNextPage" value="true" type="Boolean"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/RefundOrderAdjustmentsByRefundIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId: systemMessageRemoteId, queryText: queryText]" out-map="responseMap"/>
                <if condition="!responseMap.response?.refund">
                    <return type="warning" message="No Shopify refund found for id: ${shopifyRefundId}"/>
                </if>
                <if condition="responseMap.response.refund.orderAdjustments?.edges">
                    <script>orderAdj.addAll(responseMap.response.refund.orderAdjustments.edges.node)</script>
                </if>
                <set field="hasNextPage" from="responseMap.response.refund.orderAdjustments.pageInfo.hasNextPage"/>
                <set field="cursor" from="responseMap.response.refund.orderAdjustments.pageInfo.endCursor"/>
            </while>
        </actions>
    </service>

    <service verb="get" noun="ReturnDetailsById">
        <description>Get return details for a given Return Id</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="returnId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="returnDetail" type="Map"/>
        </out-parameters>
        <actions>
            <set field="returnDetail" from="[:]"/>

            <!-- Getting return line items detail -->
            <set field="hasNextPage" type="Boolean" value="true"/>
            <set field="returnLineItems" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/ReturnLineItemByIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="returnLineItemResponse"/>
                <if condition="returnLineItemResponse.response.return.returnLineItems.edges">
                    <script>returnLineItems.addAll(returnLineItemResponse.response.return.returnLineItems.edges.node)</script>
                </if>
                <set field="hasNextPage" from="returnLineItemResponse.response.return.returnLineItems.pageInfo.hasNextPage"/>
                <set field="cursor" from="returnLineItemResponse.response.return.returnLineItems.pageInfo.endCursor"/>
            </while>
            <set field="returnDetail.returnLineItems" from="returnLineItems"/>

            <!-- Getting exchange line items detail -->
            <set field="hasNextPage" value="true"/>
            <set field="cursor" value=""/>
            <set field="exchangeLineItems" from="[]"/>
            <while condition="hasNextPage">
                <script>
                    queryText = ec.resourceFacade.template("component://shopify-connector/template/graphQL/returnExchangeV2/ExchangeLineItemByReturnIdQuery.ftl", "")
                </script>
                <service-call name="co.hotwax.shopify.common.ShopifyHelperServices.send#ShopifyGraphqlRequest" in-map="[systemMessageRemoteId:systemMessageRemoteId, queryText:queryText]" out-map="exchangeLineItemResponse"/>
                <if condition="exchangeLineItemResponse.response.return.exchangeLineItems.edges">
                    <script>exchangeLineItems.addAll(exchangeLineItemResponse.response.return.exchangeLineItems.edges.node)</script>
                </if>
                <set field="hasNextPage" from="exchangeLineItemResponse.response.return.exchangeLineItems.pageInfo.hasNextPage"/>
                <set field="cursor" from="exchangeLineItemResponse.response.return.exchangeLineItems.pageInfo.endCursor"/>
            </while>
            <set field="returnDetail.exchangeLineItems" from="exchangeLineItems"/>
        </actions>
    </service>

    <service verb="create" noun="ShopifyRefunds" authenticate="anonymous-all">
       <description> Fetch Shopify order refund-related data using orderId and orchestrate refund attribution, return creation, and cancellation creation. </description>
       <in-parameters>
           <parameter name="systemMessageRemoteId" required="true"/>
           <parameter name="shopifyOrderId" required="true"/>
       </in-parameters>
       <actions>
        <log message="[Service Called] Entering create ShopifyRefunds service"/>
           <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
               <field-map field-name="systemMessageRemoteId"/>
           </entity-find-one>
           <if condition="!systemMessageRemote">
               <return error="true" message="Invalid systemMessageRemoteId: ${systemMessageRemoteId}"/>
           </if>
           <set field="shopId" from="systemMessageRemote.internalId"/>
           <set field="orderMap" from="[:]"/>
           <set field="orderMap.shopId" from="shopId"/>

           <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#OrderRefundAndReturnSummary" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyOrderId:shopifyOrderId]" out-map="orderRefundAndReturnSummaryOut"/>
           <set field="orderMap" from="orderMap + orderRefundAndReturnSummaryOut.order"/>

           <log message="[OrderMap] - After OrderRefundAndReturnSummary fetch: ${orderMap}"/>

           <!-- Fetch refund agreements -->
           <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundAgreements" in-map="[systemMessageRemoteId:systemMessageRemoteId, shopifyOrderId:shopifyOrderId]" out-map="orderAgreementsResponse"/>

<!--           <if condition="!orderAgreementsResponse?.refundAgreements">-->
<!--               <return type="warning" message="Order not found in Shopify. shopifyOrderId=${shopifyOrderId}, shopId=${shopId}"/>-->
<!--           </if>-->
           <set field="orderMap.refundAgreements" from="orderAgreementsResponse.refundAgreements"/>

           <log message="[RefundAgreements] - After RefundAgreements fetch: ${orderMap}"/>

           <set field="refundsList" from="[]"/>
           <!-- Fetch refund details -->
           <iterate list="orderMap.refunds" entry="refund">
               <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#RefundDetailsById" in-map="[systemMessageRemoteId:systemMessageRemoteId, refundId:refund.id]" out-map="refundDetailsOut"/>
<!--               <log message="==== refundDetailsOut: ${refundDetailsOut} ===="/>-->
               <set field="refund" from="refund + refundDetailsOut.refundDetail"/>

<!--               <log message="==== refund: ${refund} ===="/>-->

               <!-- Getting returns from refundId-->
               <if condition="refund.return?.id">
                   <service-call name="co.hotwax.shopify.return.ShopifyReturnServices.get#ReturnDetailsById" in-map="[systemMessageRemoteId:systemMessageRemoteId, returnId:refund.return.id]" out-map="returnDetailsOut"/>
                   <set field="refund.return" from="refund.return + returnDetailsOut.returnDetail"/>
               </if>
               <script>refundsList.add(refund)</script>
           </iterate>
           <set field="orderMap.refunds" from="refundsList"/>

           <log message="[RefundDetails] - After assembling refunds: ${orderMap}"/>

           <script>
               import com.fasterxml.jackson.databind.ObjectMapper
               orderMapJson = new ObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(orderMap)
           </script>


           <set field="shopifyOrderId" from="co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(shopifyOrderId)"/>

           <set field="filteredRefunds" from="[]"/>

           <!-- Go-live timestamp -->
           <!-- TODO revisit the refundGoLiveTs -->
           <set field="refundGoLiveTs" from="java.time.OffsetDateTime.parse('2025-12-30T00:00:00Z')"/>


           <iterate list="orderMap.refunds" entry="refund">
               <!-- Check if refund already processed -->
               <entity-find entity-name="co.hotwax.shopify.ShopifyRefundHistory" list="existingRefundList">
                   <econdition field-name="shopifyRefundId" from="co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refund.id)"/>
               </entity-find>
               <if condition="existingRefundList">
                   <log message="[Deduplication] - Refund ${refund.id} already processed, history: ${existingRefundList?.first}"/>
                   <continue/>
               </if>
               <!-- Skip refunds before go-live -->
               <set field="refundCreatedTs" from="java.time.OffsetDateTime.parse(refund.createdAt)"/>
               <if condition="refundCreatedTs.isBefore(refundGoLiveTs)">
                   <continue/>
               </if>
               <!-- Valid refund -->
               <script>
                   filteredRefunds.add(refund)
               </script>
           </iterate>


           <set field="orderMap.refunds" from="filteredRefunds"/>
           <if condition="!orderMap.refunds || orderMap.refunds.isEmpty()">
               <log message="[Deduplication] - No new refunds to process after de-duplication for order ${shopifyOrderId}"/>
               <return/>
           </if>
           <entity-find entity-name="org.apache.ofbiz.order.order.OrderHeader" list="hcOrderList">
               <econdition field-name="externalId" from="shopifyOrderId"/>
           </entity-find>
           <set field="hcOrder" from="hcOrderList?.first"/>
           <set field="skipAttribution" from="false" type="Boolean"/>


           <set field="returnsToCreateList" from="[]"/>
           <set field="remainingRefunds" from="[]"/>


           <!-- Orphan Return -->
           <if condition="!hcOrder">
               <log message="Order [Shopify: ${shopifyOrderId}] - No matching OMS order found, defaulting refunds to RETURN"/>
               <iterate list="orderMap.refunds" entry="refund">
                   <set field="refund.attributionType" value="RETURN"/>
                   <script>returnsToCreateList.add(refund)</script>
               </iterate>
               <set field="skipAttribution" value="true"/>
           </if>


           <!-- Extract HC Approved Order Item Quantities -->
           <if condition="hcOrder">
               <log message="Order [Shopify: ${shopifyOrderId}, OMS: ${hcOrder.orderId}] - Found matching OMS order"/>
               <!-- Fetch approved quantities (already aggregated via OrderItemDetail view) -->
               <entity-find entity-name="co.hotwax.order.OrderItemDetail" list="orderItemList">
                   <econdition field-name="orderId" from="hcOrder.orderId"/>
                   <econdition field-name="itemStatusId" value="ITEM_APPROVED"/>
                   <select-field field-name="orderItemExternalId,quantity,orderItemSeqId,shipGroupSeqId"/>
               </entity-find>

               <!-- No approved items so force default attribution -->
               <if condition="!orderItemList || orderItemList.isEmpty()">
                   <log message="Order [OMS: ${hcOrder.orderId}] - No approved items found, default refund attribution initiated"/>

                   <iterate list="orderMap.refunds" entry="refund">
                       <!-- Appeasement if no line items -->
                       <if condition="!refund.refundLineItems || refund.refundLineItems.isEmpty()">
                           <set field="refund.attributionType" value="APPEASEMENT"/>
                           <script>returnsToCreateList.add(refund)</script>
                           <log message="Refund [ID: ${refund.id}] - No line items on unapproved order, attributed as APPEASEMENT"/>
                           <continue/>
                       </if>
                       <!-- Otherwise RETURN -->
                       <set field="refund.attributionType" value="RETURN"/>
                       <script>returnsToCreateList.add(refund)</script>
                       <log message="Refund [ID: ${refund.id}] - Line items present on unapproved order, attributed as RETURN"/>
                   </iterate>
                   <set field="skipAttribution" value="true"/>
               </if>
               <log message="Refund Attribution - skipAttribution=${skipAttribution}"/>
           </if>

           <!-- Proceed with attribution only if not skipped -->
           <if condition="!skipAttribution">
               <!-- Build Approved Qty Map from OrderItemDetail -->
               <set field="approvedQtyByLineItem" from="[:]"/>
               <iterate list="orderItemList" entry="item">
                   <!-- orderItemExternalId is already Shopify LineItem ID -->
                   <set field="approvedQtyByLineItem[item.orderItemExternalId]" from="item.quantity" type="Integer"/>
               </iterate>

               <!-- Group Refund Line Items -->
               <set field="groupedRefundLineItems" from="[:]"/>
               <iterate list="orderMap.refunds" entry="refund">
                   <!-- Skip already attributed refunds -->
                   <if condition="refund.attributionType">
                       <continue/>
                   </if>

                   <!-- Refund has no line items so APPEASEMENT -->
                   <if condition="!refund.refundLineItems || refund.refundLineItems.isEmpty()">
                       <set field="refund.attributionType" value="APPEASEMENT"/>
                       <script>returnsToCreateList.add(refund)</script>
                       <continue/>
                   </if>

                   <iterate list="refund.refundLineItems" entry="refundLineItem">
                       <set field="shopifyLineItemId" from="co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundLineItem.lineItem.id)"/>

                       <if condition="groupedRefundLineItems[shopifyLineItemId] == null">
                           <set field="groupedRefundLineItems[shopifyLineItemId]" from="[:]"/>
                           <set field="groupedRefundLineItems[shopifyLineItemId].unfulfilledQuantity" from="refundLineItem.lineItem.unfulfilledQuantity ?: 0" type="Integer"/>
                           <set field="groupedRefundLineItems[shopifyLineItemId].totalRefundedQuantity" from="0" type="Integer"/>
                           <set field="groupedRefundLineItems[shopifyLineItemId].approvedQuantity" from="approvedQtyByLineItem[shopifyLineItemId] ?: 0" type="Integer"/>
                       </if>
                       <set field="groupedRefundLineItems[shopifyLineItemId].totalRefundedQuantity" from="groupedRefundLineItems[shopifyLineItemId].totalRefundedQuantity + (refundLineItem.quantity ?: 0)" type="Integer"/>
                   </iterate>
               </iterate>
               <log message="Refund Attribution - Grouped refund line items initialized: ${groupedRefundLineItems}"/>


           <!-- Calculate toCancelQty & toReturnQty -->
               <script><![CDATA[
                  groupedRefundLineItems.each { lineItemId, itemData ->
                      int approvedQty    = (itemData.approvedQuantity ?: 0) as int
                      int unfulfilledQty = (itemData.unfulfilledQuantity ?: 0) as int
                      int refundedQty    = (itemData.totalRefundedQuantity ?: 0) as int


                      int toCancelQty = approvedQty - unfulfilledQty
                      if (toCancelQty < 0) {
                          ec.logger.error("Refund quantity mismatch for order ${shopifyOrderId}, " + "lineItem ${lineItemId}. ApprovedQty=${approvedQty}, UnfulfilledQty=${unfulfilledQty}")
                          ec.message.addError("Refund discrepancy detected for order ${shopifyOrderId}. Manual intervention required.")
                          return
                      }


                      int toReturnQty = refundedQty - toCancelQty
                      itemData.toCancelQuantity = toCancelQty
                      itemData.toReturnQuantity = toReturnQty
                  }
              ]]></script>
               <log message="Order [Shopify: ${shopifyOrderId}] - Computed cancel and return quantities per line item: ${groupedRefundLineItems}"/>


               <!-- Absolute RETURN Attribution -->
               <set field="unassignedRefunds" from="[]"/>
               <set field="refundAppMap" from="[:]"/>
               <!-- TODO loop return attribution -->
               <iterate list="orderMap.refundAgreements" entry="refundAgreement">
                   <if condition="refundAgreement?.refund?.id &amp;&amp; refundAgreement?.app?.title">
                       <set field="refundAppMap[co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundAgreement.refund.id)]" from="refundAgreement.app.title"/>
                   </if>
               </iterate>
               <iterate list="orderMap.refunds" entry="refund">
                   <if condition="refund.attributionType">
                       <continue/>
                   </if>
                   <set field="refundId" from="co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refund.id)"/>
                   <set field="isReturn" from="false"/>
                   <if condition="refund.return?.id">
                       <set field="isReturn" from="true"/>
                   </if>
                   <if condition="isReturn">
                       <set field="refund.attributionType" value="RETURN"/>
                       <script>returnsToCreateList.add(refund)</script>


                       <iterate list="refund.refundLineItems" entry="refundLineItem">
                           <set field="lineItemId" from="co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundLineItem.lineItem.id)"/>
                           <set field="qty" from="refundLineItem.quantity ?: 0"/>
                           <set field="itemData" from="groupedRefundLineItems[lineItemId]"/>


                           <if condition="itemData">
                               <if condition="!itemData.returnQuantityLog">
                                   <set field="itemData.returnQuantityLog" from="[]"/>
                               </if>


                               <set field="itemData.toReturnQuantity" from="itemData.toReturnQuantity - qty" type="Integer"/>
                               <script>
                                   itemData.returnQuantityLog.add([refundId: refundId, quantityDiff: -qty])
                               </script>
                           </if>
                       </iterate>
                       <else>
                           <script>unassignedRefunds.add(refund)</script>
                       </else>
                   </if>
               </iterate>
           </if>
           <!-- CANCEL ATTRIBUTION BASED ON ZEROED OUT QUANTITIES -->
           <set field="cancelRefundsToProcess" from="[]"/>

           <script><![CDATA[
              for (refund in unassignedRefunds) {
                  if (refund.attributionType) continue
                  boolean attributed = false
                  String refundId = co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refund.id)


                  // Iterate refund line items
                  for (refundLineItem in refund.refundLineItems) {
                      String lineItemId = co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundLineItem.lineItem.id)


                      def itemData = groupedRefundLineItems[lineItemId]
                      if (!itemData) continue


                      int qty = refundLineItem.quantity ?: 0


                      // CANCEL CASE
                      if ((itemData.toCancelQuantity ?: 0) > 0) {
                          int cancelQty = Math.min(qty, itemData.toCancelQuantity)
                          // Init cancel log
                          if (!itemData.cancelQuantityLog) {
                              itemData.cancelQuantityLog = []
                          }
                          // Reduce cancel qty
                          itemData.toCancelQuantity = itemData.toCancelQuantity - cancelQty
                          // Log
                          itemData.cancelQuantityLog.add([
                              refundId    : refundId,
                              quantityDiff: -cancelQty
                          ])
                          refund.attributionType = "CANCEL"
                          cancelRefundsToProcess.add(refund)
                          attributed = true
                          break
                      }
                  }


                  // FALLBACK: RETURN IF CANCEL EXHAUSTED
                  if (!attributed) {
                      refund.attributionType = "RETURN"
                      returnsToCreateList.add(refund)
                      for (refundLineItem in refund.refundLineItems) {
                          String lineItemId =
                              co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundLineItem.lineItem.id)
                          def itemData = groupedRefundLineItems[lineItemId]
                          if (!itemData) continue
                          int qty = refundLineItem.quantity ?: 0


                          if (!itemData.returnQuantityLog) {
                              itemData.returnQuantityLog = []
                          }


                          itemData.toReturnQuantity = (itemData.toReturnQuantity ?: 0) - qty
                          itemData.returnQuantityLog.add([
                              refundId    : refundId,
                              quantityDiff: -qty
                          ])
                      }
                  }
              }
           ]]></script>
           <log message="Refund Attribution - CANCEL attributed refunds: ${cancelRefundsToProcess*.id}"/>
           <log message="Refund Attribution - RETURN refunds after CANCEL attribution: ${returnsToCreateList*.id}"/>
           <log message="Refund Attribution - Line item quantities after CANCEL attribution: ${groupedRefundLineItems}"/>


           <!-- STOP IF ALL QUANTITIES ARE ZEROED OUT -->
           <script><![CDATA[
              boolean allResolved = true
              groupedRefundLineItems.each { k, v ->
                  if ((v.toCancelQuantity ?: 0) != 0 || (v.toReturnQuantity ?: 0) != 0) {
                      allResolved = false
                  }
              }
              if (allResolved) {
                  ec.logger.info("All refund quantities fully attributed. Stopping further processing.")
              }
          ]]></script>


           <!-- PREPARE RETURN / APPEASEMENT PAYLOADS -->
           <iterate list="returnsToCreateList" entry="refund">
               <!-- transformation -->
               <set field="templateLocation" value="component://shopify-connector/template/ftl/ShopifyRefundPayload.ftl"/>
               <set field="writer" from="new StringWriter()"/>
               <set field="jsonSlurper" from="new groovy.json.JsonSlurper()"/>
               <script>
                   ec.resourceFacade.template(templateLocation, writer)
               </script>
               <set field="payLoadMap" from="jsonSlurper.parseText(writer.toString())"/>
               <set field="payLoad" from="payLoadMap.payLoad"/>
               <entity-find entity-name="co.hotwax.shopify.ShopifyConfig" list="shopifyConfigList">
                   <econdition field-name="shopId" from="shopId"/>
                   <select-field field-name="shopifyConfigId"/>
               </entity-find>
               <script><![CDATA[
                   try {
                      response = ec.service.sync().name("co.hotwax.soblegacy.order.OrderServices.create#ShopifyReturn")
                            .requireNewTransaction(true)
                            .parameters([shopifyConfigId:shopifyConfigList?.first?.shopifyConfigId, payLoad:payLoad])
                            .call()
                      ec.logger.info("Created return for refund ${refund.id}, response: ${response}")
                      } catch (Throwable e) {
                          ec.logger.error("Error creating order: ${e.getMessage()}")
                          ec.message.clearErrors()
                          ec.message.clearAll()
                          return
                      }
                   ]]></script>


               <!-- create history
                   TODO
                       1. returnId and returnItemSeqId and other fields if required
                       2. decisionType and actionType -->
               <iterate list="refund.refundLineItems" entry="refundLineItem">
                   <service-call name="create#co.hotwax.shopify.ShopifyRefundHistory" in-map="[shopifyRefundId:co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refund.id),
                       shopifyRefundLineId:co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundLineItem.id), shopifyOrderId:shopifyOrderId, shopId:shopId, orderId:hcOrder?.orderId,
                       decisionType:'FORCED', actionType:refund.attributionType, createdDate:ec.user.nowTimestamp]"/>
               </iterate>
           </iterate>
           <!-- Cancellation -->
           <iterate list="cancelRefundsToProcess" entry="refund">

               <!-- Build cancelItems ONLY for this refund -->
               <script><![CDATA[
                      cancelItems = []


                      def refundId = co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refund.id)
                      refund.refundLineItems.each { refundLineItem ->
                          def lineItemId = co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundLineItem.lineItem.id)
                          def itemData = groupedRefundLineItems[lineItemId]
                          if (!itemData?.cancelQuantityLog) return
                          def cancelLog = itemData.cancelQuantityLog.find {
                              it.refundId == refundId
                          }
                          int cancelQty = Math.abs(cancelLog.quantityDiff ?: 0)


                          def hcItem = orderItemList.find {
                              co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(it.orderItemExternalId) == lineItemId
                          }


                          cancelQty.times {
                              cancelItems.add([
                                  orderItemSeqId : hcItem.orderItemSeqId,
                                  shipGroupSeqId : hcItem.shipGroupSeqId,
                                  reason         : 'ITEM_CANCELLED',
                                  comment        : 'Cancelled via Shopify refund'
                              ])
                          }
                      }
                  ]]></script>
               <!-- Call cancel service for THIS refund -->
               <if condition="cancelItems &amp;&amp; !cancelItems.isEmpty()">
                   <script><![CDATA[
                      def cancelResp = ec.service.sync()
                          .name("co.hotwax.orderledger.order.OrderServices.cancel#SalesOrderItems")
                          .requireNewTransaction(true)
                          .parameters([
                              orderId : hcOrder.orderId,
                              items   : cancelItems
                          ])
                          .call()
                      def cancelledItems = cancelResp?.cancelledItems
                      ec.logger.info(
                          "Cancelled items response for refund ${refund.id}: ${cancelledItems}"
                      )
                  ]]></script>
               </if>
               <!-- Create PAYMENT_REFUNDED OrderPaymentPreference -->
               <!-- TODO revisit the handling below thinking of multi payment methods and handling of create/update OPP -->
               <script><![CDATA[
                      def refundTxn = refund.transactions.find { it.kind == "REFUND" }
                      BigDecimal refundedAmount = new BigDecimal(refundTxn.amountSet.shopMoney.amount ?: 0).setScale(2, BigDecimal.ROUND_HALF_UP)
                      def refundTxnId = co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundTxn.id)
                      def parentTxnId = refundTxn.parentTransaction.id ? co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundTxn.parentTransaction.id) : null
                      def existingOpp = ec.entity.find("OrderPaymentPreference").condition("orderId", hcOrder.orderId).condition("manualRefNum", refundTxnId).one()

                      if (!existingOpp) {
                          def gateway = refundTxn.gateway
                          def currencyUomId = refundTxn.amountSet?.shopMoney?.currencyCode ?: "USD"
                          def paymentMethodTypeId = ec.entity.find("co.hotwax.shopify.ShopifyShopTypeMapping")
                                                    .condition("shopId", shopId)
                                                    .condition("mappedTypeId", "PAYMENT_METHOD")
                                                    .condition("mappedKey", gateway?.toUpperCase())
                                                    .one()?.mappedValue?: "EXT_SHOP_OTHR_GTWAY"

                          ec.service.sync()
                              .name("create#org.apache.ofbiz.order.order.OrderPaymentPreference")
                              .parameters([
                                  orderId                : hcOrder.orderId,
                                  statusId               : 'PAYMENT_REFUNDED',
                                  paymentMethodTypeId    : paymentMethodTypeId,
                                  maxAmount              : refundedAmount,
                                  presentmentAmount      : refundedAmount,
                                  presentmentCurrencyUom : currencyUomId,
                                  manualRefNum           : refundTxnId,
                                  parentRefNum           : parentTxnId
                              ])
                              .call()

                          ec.logger.info(
                              "Created PAYMENT_REFUNDED OPP for refund ${refund.id}, amount=${refundedAmount}"
                          )
                      }
                  ]]></script>
               <!-- create history
                   TODO
                       1. returnId and returnItemSeqId and other fields if required
                       2. decisionType and actionType -->
               <iterate list="refund.refundLineItems" entry="refundLineItem">
                   <service-call name="create#co.hotwax.shopify.ShopifyRefundHistory" in-map="[shopifyRefundId:co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refund.id),
                       shopifyRefundLineId:co.hotwax.sob.shopify.ShopifyHelper.resolveShopifyGid(refundLineItem.id), shopifyOrderId:shopifyOrderId, shopId:shopId, orderId:hcOrder?.orderId,
                       decisionType:'FORCED', actionType:refund.attributionType, createdDate:ec.user.nowTimestamp]"/>
               </iterate>
           </iterate>
       </actions>
    </service>
</services>